<?php
/**
 * Created by PhpStorm.
 * User: vinhs
 * Date: 2019-02-22
 * Time: 13:27
 */

namespace common\components\db;

use Yii;

/**
 * Class ActiveRecord
 * @package common\components\db
 */
class ActiveRecord extends \yii\db\ActiveRecord
{

    /**
     * @inheritdoc
     * @return array
     */
    public function behaviors()
    {
        return array_merge(parent::behaviors(), [
            'timestamp' => [
                'class' => 'common\behaviors\TimestampBehavior',
                'createdAtAttribute' => $this->hasAttribute('created_at') ? 'created_at' : false,
                'updatedAtAttribute' => $this->hasAttribute('updated_at') ? 'updated_at' : false,
            ],
            'blameable' => [
                'class' => 'yii\behaviors\BlameableBehavior',
                'createdByAttribute' => $this->hasAttribute('created_by') ? 'created_by' : false,
                'updatedByAttribute' => $this->hasAttribute('updated_by') ? 'updated_by' : false
            ]
        ]);
    }


    public function formName()
    {
        return parent::formName(); // TODO: Change the autogenerated stub
    }

    public function toArray(array $fields = [], array $expand = [], $recursive = true)
    {
        return parent::toArray($fields, $expand, $recursive);
    }


    public function fields()
    {
        $fields = parent::fields();
        foreach (['created_by','updated_by'] as $name){
            if (isset($fields[$name])) {
                unset($fields[$name]);
            }
        }
        foreach (['created_at', 'updated_at'] as $name) {
            if ($this->hasAttribute($name) && isset($fields[$name])) {
                $fields[$name] = function ($model) use ($name) {
                    return Yii::$app->formatter->asDatetime($model->$name);
                };
            }
        }
        return $fields;
    }

    /**
     * Determines which fields can be returned by [[toArray()]].
     * This method will first extract the root fields from the given fields.
     * Then it will check the requested root fields against those declared in [[fields()]] and [[extraFields()]]
     * to determine which fields can be returned.
     * @param array $fields the fields being requested for exporting
     * @param array $expand the additional fields being requested for exporting
     * @return array the list of fields to be exported. The array keys are the field names, and the array values
     * are the corresponding object property names or PHP callables returning the field values.
     */
    protected function resolveFields(array $fields, array $expand)
    {

        $fields = $this->extractRootFields($fields);
        $expand = $this->extractRootFields($expand);

        $result = [];
        foreach ($this->fields() as $field => $definition) {
            if (is_int($field)) {
                $field = $definition;
            }
            if (empty($fields) || in_array($field, $fields, true)) {
                $result[$field] = $definition;
            }
        }
//        if (empty($expand)) {
//            return $result;
//        }

        foreach ($this->extraFields() as $field => $definition) {
            if (is_int($field)) {
                $field = $definition;
            }
            if (empty($expand) || in_array($field, $expand, true)) {
                $result[$field] = $definition;
            }
        }

        return $result;
    }
}